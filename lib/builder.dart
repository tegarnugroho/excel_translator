import 'dart:async';
import 'package:build/build.dart';
import 'package:path/path.dart' as path;
import 'package:yaml/yaml.dart';

import 'src/models/models.dart';
import 'src/services/services.dart';
import 'src/parsers/parsers.dart';
import 'src/utils/utils.dart';

/// Build runner builder for Excel Translator
class ExcelTranslatorBuilder implements Builder {
  @override
  final buildExtensions = const {
    r'$lib$': ['lib/generated_localizations.dart', 'lib/build_context_extension.dart'],
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    // Debug: print input
    print('ExcelTranslatorBuilder running on: ${buildStep.inputId}');

    // Only run on pubspec.yaml
    if (!buildStep.inputId.path.endsWith('pubspec.yaml')) {
      print('Skipping because input is not pubspec.yaml');
      return;
    }

    final config = await _loadConfig(buildStep);
    if (config == null) {
      print('No excel_translator configuration found in pubspec.yaml');
      return;
    }

    final excelFile = config['excel_file'] as String?;
    if (excelFile == null) {
      log.warning('No excel_file specified in excel_translator configuration');
      return;
    }

    final outputDir = config['output_dir'] as String? ?? 'lib';
    final className = config['class_name'] as String? ?? 'AppLocalizations';
    final includeFlutterDelegates = config['include_flutter_delegates'] as bool? ?? true;

    // Find the Excel file
    final excelFileAsset = AssetId(buildStep.inputId.package, excelFile);
    if (!await buildStep.canRead(excelFileAsset)) {
      log.warning('Excel file not found: $excelFile');
      return;
    }

    try {
      // Read the Excel file
      final bytes = await buildStep.readAsBytes(excelFileAsset);

      // Parse the file
      final parser = FileParserFactory.createParser(excelFile);
      final sheets = await parser.parseFileFromBytes(bytes, languageService: LanguageService());

      if (sheets.isEmpty) {
        log.warning('No sheets found in $excelFile');
        return;
      }

      // Sort sheets for consistent ordering
      sheets.sort((a, b) => a.name.compareTo(b.name));

      // Generate code
      await _generateLocalizations(buildStep, sheets, outputDir, className, includeFlutterDelegates);

      log.info('Generated localizations from $excelFile');

    } catch (e, stackTrace) {
      log.severe('Failed to generate localizations: $e\n$stackTrace');
    }
  }

  Future<Map<String, dynamic>?> _loadConfig(BuildStep buildStep) async {
    final pubspecAsset = AssetId(buildStep.inputId.package, 'pubspec.yaml');
    if (!await buildStep.canRead(pubspecAsset)) {
      return null;
    }

    final pubspecContent = await buildStep.readAsString(pubspecAsset);
    final pubspec = loadYaml(pubspecContent) as YamlMap;

    final excelTranslatorConfig = pubspec['excel_translator'];
    if (excelTranslatorConfig is! YamlMap) {
      return null;
    }

    return excelTranslatorConfig.cast<String, dynamic>();
  }

  Future<void> _generateLocalizations(
    BuildStep buildStep,
    List<LocalizationSheet> sheets,
    String outputDir,
    String className,
    bool includeFlutterDelegates,
  ) async {
    // Generate main class with all sheets
    final mainAsset = AssetId(buildStep.inputId.package, path.join(outputDir, 'generated_localizations.dart'));

    final buffer = StringBuffer();
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by Excel Translator');
    buffer.writeln();

    if (includeFlutterDelegates) {
      buffer.writeln("import 'package:flutter/material.dart';");
      buffer.writeln("import 'package:flutter/cupertino.dart';");
      buffer.writeln("import 'package:excel_translator/excel_translator.dart';");
      buffer.writeln("import 'dart:ui' show PlatformDispatcher;");
    }

    // Generate sheet classes
    for (final sheet in sheets) {
      buffer.writeln('class ${StringUtils.sanitizeClassName(sheet.name)}Localizations {');
      buffer.writeln('  final String _languageCode;');
      buffer.writeln();
      buffer.writeln('  const ${StringUtils.sanitizeClassName(sheet.name)}Localizations(this._languageCode);');
      buffer.writeln();

      // Generate methods for each translation
      for (final translation in sheet.translations) {
        final methodName = StringUtils.sanitizeMethodName(translation.key);
        buffer.writeln('  /// Translation for key: ${translation.key}');

        final hasInterpolation = translation.values.values.any(
          (value) => StringUtils.hasInterpolation(value),
        );

        if (hasInterpolation) {
          final params = StringUtils.extractInterpolationParams(
            translation.values.values.first,
          );
          final paramList = params.map((p) => 'dynamic $p').join(', ');

          buffer.writeln('  String $methodName({$paramList}) {');
          buffer.writeln('    switch (_languageCode) {');

          for (final languageCode in sheet.languageCodes) {
            final translatedValue = translation.values[languageCode] ?? '';
            final normalizedValue = StringUtils.normalizeInterpolation(translatedValue);
            buffer.writeln("      case '$languageCode':");
            buffer.writeln("        return '''$normalizedValue'''");

            for (final param in params) {
              buffer.writeln("            .replaceAll('{$param}', $param.toString())");
            }
            buffer.writeln("            ;");
          }

          buffer.writeln("      default:");
          final defaultTranslation = translation.values.values.first;
          final normalizedDefault = StringUtils.normalizeInterpolation(defaultTranslation);
          buffer.writeln("        return '''$normalizedDefault'''");
          for (final param in params) {
            buffer.writeln("            .replaceAll('{$param}', $param.toString())");
          }
          buffer.writeln("            ;");
          buffer.writeln('    }');
          buffer.writeln('  }');
        } else {
          buffer.writeln('  String get $methodName {');
          buffer.writeln('    switch (_languageCode) {');

          for (final languageCode in sheet.languageCodes) {
            final translatedValue = translation.values[languageCode] ?? '';
            buffer.writeln("      case '$languageCode':");
            buffer.writeln("        return '''$translatedValue''';");
          }

          buffer.writeln("      default:");
          final defaultTranslation = translation.values.values.first;
          buffer.writeln("        return '''$defaultTranslation''';");
          buffer.writeln('    }');
          buffer.writeln('  }');
        }
        buffer.writeln();
      }

      buffer.writeln('}');
      buffer.writeln();
    }

    // Generate main class
    buffer.writeln('class $className {');
    buffer.writeln('  final String languageCode;');
    buffer.writeln();

    // Add supported languages list
    final allLanguageCodes = <String>{};
    for (final sheet in sheets) {
      allLanguageCodes.addAll(sheet.languageCodes);
    }
    final sortedLanguages = allLanguageCodes.toList()..sort();

    buffer.writeln('  static const List<String> supportedLanguages = [');
    for (final lang in sortedLanguages) {
      buffer.writeln("    '$lang',");
    }
    buffer.writeln('  ];');
    buffer.writeln();

    // Add sheet properties
    for (final sheet in sheets) {
      final sheetClassName = '${StringUtils.sanitizeClassName(sheet.name)}Localizations';
      final propertyName = StringUtils.sanitizePropertyName(sheet.name);
      buffer.writeln('  late final $sheetClassName $propertyName;');
    }
    buffer.writeln();

    // Constructor
    buffer.writeln('  $className(this.languageCode) {');
    for (final sheet in sheets) {
      final sheetClassName = '${StringUtils.sanitizeClassName(sheet.name)}Localizations';
      final propertyName = StringUtils.sanitizePropertyName(sheet.name);
      buffer.writeln('    $propertyName = $sheetClassName(languageCode);');
    }
    buffer.writeln('  }');
    buffer.writeln();

    if (includeFlutterDelegates) {
      // Add static helper methods for common languages
      final languageService = LanguageService();
      final addedGetters = <String>{};

      for (final lang in sortedLanguages.take(5)) {
        final capitalizedLang = languageService.getLanguageName(lang);
        final camelCaseLang = StringUtils.sanitizePropertyName(lang);
        buffer.writeln('  /// Get $capitalizedLang instance');
        buffer.writeln("  static $className get $camelCaseLang => $className('$lang');");
        addedGetters.add(camelCaseLang);
      }
      buffer.writeln();

      // Add convenience static getters with full names
      for (final lang in sortedLanguages.take(5)) {
        final fullName = languageService.getLanguageName(lang);
        final camelCaseFullName = StringUtils.sanitizePropertyName(fullName);
        final camelCaseLang = StringUtils.sanitizePropertyName(lang);
        if (!addedGetters.contains(camelCaseFullName) && camelCaseFullName != camelCaseLang) {
          buffer.writeln("  static $className get $camelCaseFullName => $className('$lang');");
        }
      }
      buffer.writeln();

      // Static method for getting instance from context
      buffer.writeln('  static $className of(BuildContext context) {');
      buffer.writeln('    final locale = Localizations.localeOf(context);');
      buffer.writeln('    return $className(locale.languageCode);');
      buffer.writeln('  }');
      buffer.writeln();

      // Get system language with fallback
      buffer.writeln('  /// Get system language with fallback');
      buffer.writeln('  static String getSystemLanguage() {');
      buffer.writeln('    try {');
      buffer.writeln('      final locales = PlatformDispatcher.instance.locales;');
      buffer.writeln('      if (locales.isNotEmpty) {');
      buffer.writeln('        final locale = locales.first.languageCode.toLowerCase();');
      buffer.writeln('        if (supportedLanguages.contains(locale)) {');
      buffer.writeln('          return locale;');
      buffer.writeln('        }');
      buffer.writeln('      }');
      buffer.writeln('    } catch (e) {');
      buffer.writeln('    }');
      buffer.writeln("    return 'en';");
      buffer.writeln('  }');
      buffer.writeln();

      // Add current getter
      buffer.writeln('  /// Get current localization based on system language');
      buffer.writeln('  static $className get current => $className(getSystemLanguage());');
      buffer.writeln();

      // Add Flutter delegates
      buffer.writeln('  /// Delegate for localizations');
      buffer.writeln('  static const ${className}Delegate delegate = ${className}Delegate();');
      buffer.writeln();
      buffer.writeln('  /// All localization delegates including Flutter\'s built-in delegates');
      buffer.writeln('  static const List<LocalizationsDelegate<dynamic>> delegates = [');
      buffer.writeln('    delegate, // Custom localizations');
      buffer.writeln('    GlobalMaterialLocalizations.delegate,');
      buffer.writeln('    GlobalWidgetsLocalizations.delegate,');
      buffer.writeln('    GlobalCupertinoLocalizations.delegate,');
      buffer.writeln('  ];');
      buffer.writeln();
    }

    buffer.writeln('}');

    // Add delegate class if Flutter delegates are enabled
    if (includeFlutterDelegates) {
      buffer.writeln();
      buffer.writeln('class ${className}Delegate extends LocalizationsDelegate<$className> {');
      buffer.writeln('  const ${className}Delegate();');
      buffer.writeln();
      buffer.writeln('  @override');
      buffer.writeln('  bool isSupported(Locale locale) {');
      buffer.writeln('    return $className.supportedLanguages.contains(locale.languageCode);');
      buffer.writeln('  }');
      buffer.writeln();
      buffer.writeln('  @override');
      buffer.writeln('  Future<$className> load(Locale locale) async {');
      buffer.writeln('    return $className(locale.languageCode);');
      buffer.writeln('  }');
      buffer.writeln();
      buffer.writeln('  @override');
      buffer.writeln('  bool shouldReload(${className}Delegate old) => false;');
      buffer.writeln('}');
    }

    await buildStep.writeAsString(mainAsset, buffer.toString());

    // Generate BuildContext extension
    final extensionAsset = AssetId(buildStep.inputId.package, path.join(outputDir, 'build_context_extension.dart'));

    final extensionBuffer = StringBuffer();
    extensionBuffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    extensionBuffer.writeln('// Generated by Excel Translator');
    extensionBuffer.writeln();
    extensionBuffer.writeln('// Uncomment the lines below to enable BuildContext extension');
    extensionBuffer.writeln('// This provides easy access like: context.loc.localizations.hello');
    extensionBuffer.writeln('//');
    extensionBuffer.writeln("// import 'package:flutter/material.dart';");
    extensionBuffer.writeln("// import 'generated_localizations.dart';");
    extensionBuffer.writeln('//');
    extensionBuffer.writeln('// extension LocalizationsExtension on BuildContext {');
    extensionBuffer.writeln('//   $className get loc => $className.of(this);');
    extensionBuffer.writeln('// }');

    await buildStep.writeAsString(extensionAsset, extensionBuffer.toString());
  }
}

Builder excelTranslatorBuilder(BuilderOptions options) => ExcelTranslatorBuilder();